#########################################################################
#       Copyright (C) 2010-2012 William Stein <wstein@gmail.com>
#
#  Distributed under the terms of the GNU General Public License (GPL)
#
#                  http://www.gnu.org/licenses/
#########################################################################

from sage.misc.all import cputime
from sage.rings.all import Integer, ZZ, gcd

from sqrt5 import F, O_F
from sqrt5_fast import IcosiansModP1ModN


def ideals_of_bounded_norm(B):
    r"""
    Return all ideals in the ring of integers of Q(sqrt(5)) with norm
    bigger than 1 and <= B.
    
    INPUT:

    - `B` -- positive integer

    OUTPUT:

    - list of ideals

    EXAMPLES::

        sage: v = sage.modular.hilbert.sqrt5_tables.ideals_of_bounded_norm(11); v
        [Fractional ideal (2), Fractional ideal (-2*a + 1), Fractional ideal (3), Fractional ideal (-3*a + 1), Fractional ideal (-3*a + 2)]
        sage: [I.norm() for I in v]
        [4, 5, 9, 11, 11]
    """
    return sum([v for n, v in F.ideals_of_bdd_norm(B).iteritems() if n != 1], [])
    
def ideals_of_norm(v):
    """
    INPUT:

    - `v` -- integer >= 2, or list of integers >= 2

    OUTPUT:

    - list of ideals of all ideals that have norm in v that is >= 2.

    EXAMPLES::

        sage: sage.modular.hilbert.sqrt5_tables.ideals_of_norm(4)
        [Fractional ideal (2)]
        sage: sage.modular.hilbert.sqrt5_tables.ideals_of_norm([9,11])
        [Fractional ideal (3), Fractional ideal (-3*a + 1), Fractional ideal (-3*a + 2)]
        sage: sage.modular.hilbert.sqrt5_tables.ideals_of_norm([4*5])
        [Fractional ideal (-4*a + 2)]
        sage: sage.modular.hilbert.sqrt5_tables.ideals_of_norm(4*5)
        [Fractional ideal (-4*a + 2)]        
    """
    try:
        v = list(v)
    except TypeError:
        v = [Integer(v)]
    z = F.ideals_of_bdd_norm(max(v))
    return sum([z[n] for n in v if n>1],[])

def reduced_gen(I):
    """
    Return a choice of reduced generator for the ideal I, which must
    be principal.

    The implementation computes the Hermite normal form (HNF) basis of
    I, which is canonical, then finds a reduced generator (as defined
    by PARI) for the ideal J generated by that canonical basis.

    INPUT:

    - `I` -- ideal of ring of integers of a number field, or a
      rational integer

    OUTPUT:

    - I, a generator of I, or raise a ValueError if I is not principal

    EXAMPLES::

        sage: from sage.modular.hilbert.sqrt5_tables import F, reduced_gen
        sage: a = F.0
        sage: z = a^30  * (-45*a+28); z
        -37284985*a - 23043388
        sage: reduced_gen(F.ideal(z))
        -45*a + 28

    Just returns a rational integer in case that is the input::
    
        sage: reduced_gen(15)
        15
        sage: reduced_gen(int(15))
        15
        sage: reduced_gen(long(15))
        15

    When the ideal is not principal, a ValueError is raised::

        sage: K.<a> = QuadraticField(-23)
        sage: I = K.class_group().gen().ideal()
        sage: reduced_gen(I)
        Traceback (most recent call last):
        ...
        ValueError: ideal must be principal
    """
    if isinstance(I, (int, long, Integer)):
        return Integer(I)
    g =  I.ring().ideal(I.basis()).gens_reduced()
    if len(g) != 1:
        raise ValueError, "ideal must be principal"
    return g[0]

def reduced_rep(z):
    """
    Return reduced generator for the ideal generated by z.  See the
    documentation for the reduced_gen function.

    INPUT:

    - `z` -- element of ring of integers of a number field

    OUTPUT:

    - another element that differs from z by a unit and is "reduced".

    EXAMPLES::

        sage: from sage.modular.hilbert.sqrt5_tables import F, reduced_rep
        sage: a = F.0
        sage: z = a^30  * (-45*a+28); z
        -37284985*a - 23043388
        sage: w = reduced_rep(z); w
        -45*a + 28
        sage: (z/w).norm()
        1

    On integers::
    
        sage: reduced_rep(19)
        19
        sage: reduced_rep(-19)
        19

    In a field of class number bigger than 1, which isn't a problem,
    since the ideal generated by z is principal::

        sage: K.<a> = QuadraticField(-23)
        sage: reduced_rep(-17*a - 3)
        17*a + 3
        sage: reduced_rep(17*a +3)
        17*a + 3    
    """
    if isinstance(z, (int, long, Integer)):
        if z < 0:
            return -z
        return z
    return reduced_gen(z.parent().ideal(z))
    
def test_reduced_rep(B=50):
    """
    Unit test: run a simple consistency check that reduced_rep is
    working sensibly.
    
    INPUT:

    - `B` -- positive integer

    OUTPUT:

    - None (assertion raised if something detected wrong)

    EXAMPLES::

        sage: sage.modular.hilbert.sqrt5_tables.test_reduced_rep()
    """
    a = F.gen()
    z = -45*a + 28
    v = [reduced_rep(a**i * z)  for i in range(-B,B)]
    assert len(set(v)) == 1
        

def no_space(s):
    """
    Remove all spaces from the string s.
    
    INPUT:

    - `s` -- string

    OUTPUT:

    - string

    EXAMPLES::

        sage: sage.modular.hilbert.sqrt5_tables.no_space('this is  it: [1, 2, 3]')
        'thisisit:[1,2,3]'    
    """
    return str(s).replace(' ', '')

def dimensions(v, filename=None):
    """
    Compute dimensions of spaces of Hilbert modular forms for all the levels in v.
    The format is:

        Norm   dimension  generator  time

    INPUT:

    - `v` -- list of positive integers
    - ``filename`` -- optional string; if given, output is also written
      to that file (in addition to stdout).

    OUTPUT:

    - appends to table with above format and rows corresponding to the
      ideals of Q(sqrt(5)) with norm in v, and optionally creates a
      file

    EXAMPLES::

        sage: from sage.modular.hilbert.sqrt5_tables import dimensions
        sage: out = dimensions([1..40])
        4 1 2 ...
        5 1 -2*a+1 ...
        9 1 3 ...
        11 1 -3*a+1 ...
        11 1 -3*a+2 ...
        16 1 4 ...
        19 1 -4*a+1 ...
        19 1 -4*a+3 ...
        20 1 -4*a+2 ...
        25 1 5 ...
        29 1 a-6 ...
        29 1 -a-5 ...
        31 2 5*a-3 ...
        31 2 5*a-2 ...
        36 2 6 ...
        sage: out = dimensions([36, 4])
        36 2 6 ...
        4 1 2 ...

    Test writing to a file::

        sage: if os.path.exists('tmp_table.txt'): os.unlink('tmp_table.txt')
        sage: out = dimensions([36, 4], 'tmp_table.txt')
        36 2 6 ...
        4 1 2 ...
        sage: '36 2 6' in open('tmp_table.txt').read()
        True
        sage: open('tmp_table.txt').read().count('\n')
        2
        sage: os.unlink('tmp_table.txt')    
    """
    if len(v) == 0:
        return ''
    F = open(filename,'a') if filename else None
    out = ''
    for N in ideals_of_norm(v):
        t = cputime()
        H = IcosiansModP1ModN(N)
        tm = '%.2f'%cputime(t)
        s = '%s %s %s %s'%(N.norm(), H.cardinality(),
                           no_space(reduced_gen(N)), tm)
        print s
        out += s + '\n'
        if F:
            F.write(s+'\n')
            F.flush()
    return out

def charpolys(v, B, filename=None):
    """
    Compute characteristic polynomials of T_P for primes P with norm
    <= B coprime to the level, for all spaces of Hilbert modular forms
    for all the levels in v.

    INPUT:

    - `v` -- list of positive integers
    - `B` -- positive integer
    - ``filename`` -- optional string; if given, output is also written
      to that file (in addition to stdout).

    OUTPUT:

    - outputs a table with rows corresponding to the ideals
      of Q(sqrt(5)) with norm in v, and optionally creates a file

    EXAMPLES::

        sage: from sage.modular.hilbert.sqrt5_tables import charpolys
        sage: out = charpolys([1..20], 10)
        4 2 ... [(5,x-6),(3,x-10)]
        5 -2*a+1 ... [(2,x-5),(3,x-10)]
        9 3 ... [(2,x-5),(5,x-6)]
        11 -3*a+1 ... [(2,x-5),(5,x-6),(3,x-10)]
        11 -3*a+2 ... [(2,x-5),(5,x-6),(3,x-10)]
        16 4 ... [(5,x-6),(3,x-10)]
        19 -4*a+1 ... [(2,x-5),(5,x-6),(3,x-10)]
        19 -4*a+3 ... [(2,x-5),(5,x-6),(3,x-10)]
        20 -4*a+2 ... [(3,x-10)]

        sage: out = charpolys([20, 11], 10)
        20 -4*a+2 ... [(3,x-10)]
        11 -3*a+1 ... [(2,x-5),(5,x-6),(3,x-10)]
        11 -3*a+2 ... [(2,x-5),(5,x-6),(3,x-10)]

    Test writing to a file::

        sage: if os.path.exists('tmp_table.txt'): os.unlink('tmp_table.txt')
        sage: out = charpolys([20, 11], 10, 'tmp_table.txt')
        20 -4*a+2 ... [(3,x-10)]
        11 -3*a+1 ... [(2,x-5),(5,x-6),(3,x-10)]
        11 -3*a+2 ... [(2,x-5),(5,x-6),(3,x-10)]
        sage: r = open('tmp_table.txt').read()
        sage: 'x-10' in r
        True
        sage: r.count('\n')
        3
        sage: os.unlink('tmp_table.txt')    
    """
    if len(v) == 0:
        return ''
    out = ''
    F = open(filename,'a') if filename else None
    P = [p for p in ideals_of_bounded_norm(B) if p.is_prime()]
    for N in ideals_of_norm(v):
        t = cputime()
        H = IcosiansModP1ModN(N)
        T = [(p.smallest_integer(),H.hecke_matrix(p).fcp()) for p in P if
             gcd(Integer(p.norm()), Integer(N.norm())) == 1]
        tm = '%.2f'%cputime(t)
        s = '%s %s %s %s'%(N.norm(), no_space(reduced_gen(N)), tm, no_space(T))
        print s
        out += s + '\n'
        if F:
            F.write(s+'\n')
            F.flush()
    return out


def rational_newforms(v, B=100, filename=None, ncpu=1):
    """
    Return system of Hecke eigenvalues corresponding to rational
    newforms of level whose norm is in v.  Compute the Hecke
    eigenvalues a_P for all good primes P with norm < B.
    
    INPUT:

    - `v` -- list of integers
    - `B` -- positive integer
    - ``filename`` -- optional filename
    - ``ncpu`` -- positive integer (default: 1); if > 1 then use ncpu
      simultaneous processes.  Note that that displayed output during
      the computation and to the file may be out of order.  
    

    OUTPUT:

    - outputs a table with rows corresponding to the ideals
      of Q(sqrt(5)) with norm in v, and optionally creates a file

    Table columns:

        norm_of_level generator_of_level number time_for_level a_P a_P ... 

    EXAMPLES::

        sage: from sage.modular.hilbert.sqrt5_tables import rational_newforms
        sage: out = rational_newforms([1..76], B=20)
        31 5*a-3 0 ... -3 -2 2 4 -4 -4 4
        31 5*a-2 0 ... -3 -2 2 -4 4 4 -4
        36 6 0 ... ? -4 ? 2 2 0 0
        41 a-7 0 ... -2 -1 -4 -2 5 -1 6
        41 a+6 0 ... -2 -1 -4 5 -2 6 -1
        45 -6*a+3 0 ... -3 ? ? -4 -4 4 4
        49 7 0 ... 0 -4 5 -3 -3 0 0
        55 a+7 0 ... -1 ? -2 ? 0 8 -4
        55 -a+8 0 ... -1 ? -2 0 ? -4 8
        64 8 0 ... 0 -2 2 -4 -4 4 4
        71 a-9 0 ... -1 0 -2 0 0 -4 2
        71 a+8 0 ... -1 0 -2 0 0 2 -4
        76 -8*a+2 0 ... ? -3 1 3 -6 ? -7
        76 -8*a+2 1 ... ? 1 -5 -3 2 ? 5
        76 -8*a+6 0 ... ? -3 1 -6 3 -7 ?
        76 -8*a+6 1 ... ? 1 -5 2 -3 5 ?
        
    Test writing to a file::

        sage: if os.path.exists('tmp_table.txt'): os.unlink('tmp_table.txt')
        sage: out = rational_newforms([1..36], 20,'tmp_table.txt')
        31 5*a-3 0 ... -3 -2 2 4 -4 -4 4
        31 5*a-2 0 ... -3 -2 2 -4 4 4 -4
        36 6 0 ... ? -4 ? 2 2 0 0
        sage: r = open('tmp_table.txt').read()
        sage: r.count('\n')
        3
        sage: os.unlink('tmp_table.txt')    
    """
    if len(v) == 0:
        return ''
    
    if ncpu < 1:
        raise ValueError, 'ncpu must be >= 1'

    F = open(filename,'a') if filename else None
    if ncpu > 1:
        from sage.all import parallel
        @parallel(ncpu)
        def f(N):
            return rational_newforms([N], B, filename=None, ncpu=1)
        d = {}
        for X in f(v):
            N = X[0][0]
            ans = X[1].strip()
            if ans:
                d[N] = ans
                if F:
                    F.write(ans + '\n')
        return '\n'.join(d[N] for N in sorted(d.keys()))

    out = ''
    from sqrt5_hmf import QuaternionicModule
    for N in ideals_of_norm(v):
        t = cputime()
        H = QuaternionicModule(N)
        EC = H.rational_newforms()
        tm = '%.2f'%cputime(t)
        for i, E in enumerate(EC):
            v = E.aplist(B)
            data = [N.norm(), no_space(reduced_gen(N)), i, tm, 
                    ' '.join([no_space(x) for x in v])]
            s = ' '.join([str(x) for x in data])
            print s
            out += s + '\n'
            if F:
                F.write(s+'\n')
                F.flush()
    return out

                              
#################################################################

from sage.rings.all import is_Ideal

def sqrt5_ideal(X):
    """
    Return ideal in ring of integers of Q(sqrt(5)) defined by X.

    INPUT:

    - `X` -- ideal or list or element of F

    OUTPUT:

    - ideal

    EXAMPLES::

        sage: from sage.modular.hilbert.sqrt5_tables import F, sqrt5_ideal
        sage: sqrt5_ideal(7)
        Fractional ideal (7)
        sage: sqrt5_ideal(F.0)
        Fractional ideal (a)
        sage: sqrt5_ideal([F.0, 2])
        Fractional ideal (1)    
    """
    if not is_Ideal(X) or X.ring() != F:
        return O_F.ideal(X)
    return X


from sqrt5_prime import primes_of_bounded_norm

def prime_ideals_of_bounded_norm_coprime_to(I, B, sage_ideal=True):
    """
    Return prime ideals of ring of integers of Q(sqrt(5)) with norm <
    B coprime to the ideal I.

    INPUT:
    
    - `I` -- ideal (or integer)
    - `B` -- positive integer
    - ``sage_ideal`` -- bool (default: True); if True return usual
      Sage ideals.  If False, return the fast (but functionally
      limited) prime ideals defined in the sqrt5_prime module.

    OUTPUT:

    - list of prime ideals

    EXAMPLES::

        sage: from sage.modular.hilbert.sqrt5_tables import prime_ideals_of_bounded_norm_coprime_to, F
        sage: prime_ideals_of_bounded_norm_coprime_to(6, 20, sage_ideal=False)
        [5a, 11a, 11b, 19a, 19b]
        sage: prime_ideals_of_bounded_norm_coprime_to(11, 20, sage_ideal=False)
        [2, 5a, 3, 19a, 19b]
        sage: prime_ideals_of_bounded_norm_coprime_to(F.primes_above(11)[0], 20, sage_ideal=False)
        [2, 5a, 3, 11a, 19a, 19b]
        sage: prime_ideals_of_bounded_norm_coprime_to(F.primes_above(11)[1], 20, sage_ideal=False)
        [2, 5a, 3, 11b, 19a, 19b]
        sage: prime_ideals_of_bounded_norm_coprime_to(1, 10)
        [Fractional ideal (2), Fractional ideal (-2*a + 1), Fractional ideal (3)]
    """
    I = sqrt5_ideal(I)
    A = primes_of_bounded_norm(B)
    N = I.norm()
    X = []
    for P in A:
        if N % P.p:
            # easy case -- res char coprime
            X.append(P.sage_ideal() if sage_ideal else P)
        else:
            # harder case
            J = P.sage_ideal()
            if I.is_coprime(J):
                X.append(J if sage_ideal else P)
    return X

from sage.rings.all import infinity

class PrimesCoprimeTo(object):
    """
    Iterator over ordered list of prime ideals of the ring of integers
    of Q(sqrt(5)) that are coprime to a given ideal I.

    EXAMPLES::

        sage: from sage.modular.hilbert.sqrt5_tables import PrimesCoprimeTo

    Iterator over the infinitely many primes coprime to 6::
    
        sage: P = PrimesCoprimeTo(6)
        sage: p = P.next(); p
        Fractional ideal (-2*a + 1)
        sage: p.norm()
        5
        sage: p = P.next(); p
        Fractional ideal (-3*a + 1)
        sage: p.norm()
        11

    Same iterator, but over the fast sqrt5 prime objects::
    
        sage: P = PrimesCoprimeTo(6, sage_ideal=False)
        sage: P.next()
        5a
        sage: P.next()
        11a
        sage: P.next()
        11b
        
    Primes coprime to a prime over 11 with norm less than 20, using
    both Sage ideals and fast sqrt5 primes::

        sage: from sage.modular.hilbert.sqrt5_tables import PrimesCoprimeTo, F
        sage: p = F.prime_above(11)
        sage: v = PrimesCoprimeTo(p, 20); v
        Iterator over the primes of norm strictly less than 20 of the ring of integers of Q(sqrt(5)) coprime to Fractional ideal (-3*a + 2) of norm 11
        sage: list(v)
        [Fractional ideal (2), Fractional ideal (-2*a + 1), Fractional ideal (3), Fractional ideal (-3*a + 1), Fractional ideal (-4*a + 1), Fractional ideal (-4*a + 3)]
        sage: from sage.modular.hilbert.sqrt5_tables import PrimesCoprimeTo, F
        sage: p = F.prime_above(11)
        sage: v = PrimesCoprimeTo(p, 20, sage_ideal=False); v
        Iterator over the primes of norm strictly less than 20 of the ring of integers of Q(sqrt(5)) coprime to Fractional ideal (-3*a + 2) of norm 11
        sage: list(v)
        [2, 5a, 3, 11a, 19a, 19b]    
    """
    def __init__(self, I, B=None, sage_ideal=True):
        """
        INPUT:

        - `I` -- ideal (or integer)
        - `B` -- None or positive integer (default: None)
        - ``sage_ideal`` -- bool (default: True)

        EXAMPLES::
        
            sage: from sage.modular.hilbert.sqrt5_tables import PrimesCoprimeTo, F
            sage: I = F.prime_above(11)*F.prime_above(31)*F.prime_above(7)
            sage: v = PrimesCoprimeTo(I, 59, sage_ideal=False); type(v)
            <class 'sage.modular.hilbert.sqrt5_tables.PrimesCoprimeTo'>
            sage: list(v)
            [2, 5a, 3, 11a, 19a, 19b, 29a, 29b, 31a, 41a, 41b]        
        """
        self._sage_ideal = sage_ideal
        self._I = sqrt5_ideal(I)
        self._bounded = B is not None
        self._B = 50 if B is None else B
        self._v = prime_ideals_of_bounded_norm_coprime_to(
            self._I, self._B, self._sage_ideal)
        self._i = 0
        
    def __repr__(self):
        """
        EXAMPLES::
        
            sage: from sage.modular.hilbert.sqrt5_tables import PrimesCoprimeTo
            sage: PrimesCoprimeTo(3, 20).__repr__()
            'Iterator over the primes of norm strictly less than 20 of the ring of integers of Q(sqrt(5)) coprime to Fractional ideal (3) of norm 9'
        """
        return "Iterator over the primes of %sthe ring of integers of Q(sqrt(5)) coprime to %s of norm %s"%(
            'norm strictly less than %s of '%self._B if self._bounded else '', self._I, self._I.norm())

    def __iter__(self):
        """
        Support iterator protocol.

        EXAMPLES::

            sage: from sage.modular.hilbert.sqrt5_tables import PrimesCoprimeTo
            sage: v = PrimesCoprimeTo(3, 20, sage_ideal=False)
            sage: v.__iter__() is v
            True
            sage: list(v)
            [2, 5a, 11a, 11b, 19a, 19b]
            sage: v = PrimesCoprimeTo(3, 20, sage_ideal=False)
            sage: v.next(), v.next()
            (2, 5a)
            sage: list(v)
            [11a, 11b, 19a, 19b]            
        """
        return self

    def __len__(self):
        """
        Number of primes left in this iterator.

        EXAMPLES::

            sage: from sage.modular.hilbert.sqrt5_tables import PrimesCoprimeTo
            sage: v = PrimesCoprimeTo(3, 20)
            sage: len(v)
            6

        Note that len returns the number of primes left in the iterator::
        
            sage: v.next(), v.next()
            (Fractional ideal (2), Fractional ideal (-2*a + 1))
            sage: len(v)
            4
            sage: list(v)
            [Fractional ideal (-3*a + 1), Fractional ideal (-3*a + 2), Fractional ideal (-4*a + 1), Fractional ideal (-4*a + 3)]
            sage: len(v)
            0

        An infinite iterator::
        
            sage: v = PrimesCoprimeTo(3)
            sage: len(v)
            Traceback (most recent call last):
            ...
            ValueError: infinitely many primes            
        """
        if self._bounded:
            return len(self._v) - self._i
        raise ValueError, "infinitely many primes"

    def next(self):
        """
        Return next prime ideal.

        OUTPUT:
        
        - prime ideal, or raise StopIteration

        EXAMPLES::

            sage: from sage.modular.hilbert.sqrt5_tables import PrimesCoprimeTo
            sage: v = PrimesCoprimeTo(3, 12, sage_ideal=False)
            sage: v.next(), v.next()
            (2, 5a)
            sage: v.next(), v.next()
            (11a, 11b)
            sage: v.next()
            Traceback (most recent call last):
            ...
            StopIteration
        """
        if self._i >= len(self._v):
            if self._bounded:
                raise StopIteration
            self._B *= 2
            self._v = prime_ideals_of_bounded_norm_coprime_to(
                self._I, self._B, self._sage_ideal)
        self._i += 1
        return self._v[self._i-1]

